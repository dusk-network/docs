---
title: Hashing Algorithms
description: Learn about the hashing algorithms used by Dusk
---

This document provides an overview of the hashing algorithms used in Dusk, together with the information in which context and where they are used.

:::tip[Quick Information]
- A Block hash is created with **SHA3-256**.
- Transaction IDs i.e., hashes are generated using a hash_to_scalar function, which employs **BLAKE2b** as its internal hasher before mapping the result to a BLS scalar.
- Contract IDs (Address of a Contract) are created using **BLAKE2b**.
:::

### [Blake3](https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE3)

- [Contract Bytecode Hash](https://github.com/dusk-network/rusk/blob/9e291c8bcfb4797c42440a3f9cb4969cad23bc42/vm/src/execute.rs#L190):
To prevent malleability, a verification check is performed before deploying a contract. This ensures that the stored bytecode hash matches the contract's actual bytecode. The hash is generated by hashing the entire bytecode of the contract using Blake3.
- [Contract Events Bloom Filter](https://github.com/dusk-network/rusk/blob/4ed14f517e0cab2ab1e1e8fe1deb13ca29b8dbe3/rusk/src/lib/bloom.rs#L139):
Bloom filters are used to efficiently test the membership of events emitted by contracts. Blake3 is used as the hashing algorithm for our Bloom.

### [Blake2b](https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2)

- [Contract ID](https://github.com/dusk-network/rusk/blob/9e291c8bcfb4797c42440a3f9cb4969cad23bc42/vm/src/execute.rs#L211):
The contract ID of a smart contract is generated by hashing the contract bytecode, a unique nonce, and the contract
owner with Blake2b.
- ["hash" Host Function](https://github.com/dusk-network/rusk/blob/9e291c8bcfb4797c42440a3f9cb4969cad23bc42/vm/src/host_queries.rs#L48): The abi host function `hash` computes a [hash_to_scalar](https://github.com/dusk-network/bls12_381/blob/c29968598ba6584ae4037650dadb98d35a2b0c47/src/scalar/dusk.rs#L282) with Blake2b as its underlying hasher to hash a vector of bytes and then convert it to a BLS12-381 scalar.
- [Transaction ID](https://github.com/dusk-network/rusk/blob/8d64e7e63a81ddd7fbe5f92b798d94ddbe46346c/node-data/src/ledger/transaction.rs#L81): The ID of a transaction is a BLS12-381 scalar, that is generated through the hash_to_scalar function which uses Blake2b as its internal hasher.
Both [shielded](https://github.com/dusk-network/rusk/blob/8d64e7e63a81ddd7fbe5f92b798d94ddbe46346c/core/src/transfer/phoenix.rs#L535)
and [public](https://github.com/dusk-network/rusk/blob/8d64e7e63a81ddd7fbe5f92b798d94ddbe46346c/core/src/transfer/moonlight.rs#L330) transactions derive their respective Tx IDs from a Blake2b hash of their data, which is then converted into a BLS scalar.
- Payload Hash of shielded transactions: A shielded transaction payload is [hashed](https://github.com/dusk-network/rusk/blob/8d64e7e63a81ddd7fbe5f92b798d94ddbe46346c/core/src/transfer/phoenix.rs#L759) using the same hash_to_scalar. This scalar is [used as an input](https://github.com/dusk-network/rusk/blob/8d64e7e63a81ddd7fbe5f92b798d94ddbe46346c/core/src/transfer/phoenix.rs#L556) to the zero knowledge circuit for verifying shielded transactions.
- [Hash Shielded Withdrawal](https://github.com/dusk-network/rusk/blob/8d64e7e63a81ddd7fbe5f92b798d94ddbe46346c/core/src/transfer/withdraw.rs#L52): To create a signature for a shielded withdrawal, the message is hashed using hash_to_scalar, allowing the resulting BLS scalar to be signed with a shielded secret key.

### [SHA2-256](https://en.wikipedia.org/wiki/SHA-2)

- [CRS Integrity Check](https://github.com/dusk-network/rusk/blob/748edcd5e9e16caffa15c02b3c6f3f4885a026dc/rusk-profile/src/lib.rs#L180): To verify the integrity of the Common Reference String (CRS) (prevent CRS Mismatch) a SHA-256 hash gets generated and compared with a correctly defined CRS hash constant.
- [Secret Key Derivation](https://github.com/dusk-network/rusk/blob/748edcd5e9e16caffa15c02b3c6f3f4885a026dc/wallet-core/src/keys.rs#L108): SHA-256 is used for key derivation. In `rng_with_index`, a seed, key index, and a termination constant are hashed to produce a value that seeds a `ChaCha12` CSPRNG. The resulting random value based on that hash seed is then used to generate the actual keys. The termination string ensures domain separation between public and shielded key pairs.

### [SHA3-256](https://en.wikipedia.org/wiki/SHA-3)

- [Committee Creation for Consensus](https://github.com/dusk-network/rusk/blob/748edcd5e9e16caffa15c02b3c6f3f4885a026dc/consensus/src/user/sortition.rs#L72): In the consensus protocol, [committees are created](https://github.com/dusk-network/rusk/blob/748edcd5e9e16caffa15c02b3c6f3f4885a026dc/consensus/src/user/provisioners.rs#L193) using an algorithm called
deterministic sortition. First, a score is computed, and based on that score, eligible provisioners are selected. The score is computed using an SHA3-256 hash of some parameters of the consensus round.
- [Block Hash Computation](https://github.com/dusk-network/rusk/blob/748edcd5e9e16caffa15c02b3c6f3f4885a026dc/node-data/src/ledger/block.rs#L43): SHA3-256 is used to compute the hash of a block.
- [Merkle Roots](https://github.com/dusk-network/rusk/blob/cbb3f728d43c0e79e02ebd27757cbaf36f64b3cd/consensus/src/proposal/block_generator.rs#L51): The merkle roots of the faults and transactions in a block are recorded in the block header for
validation. Before their merkle roots are derived, all block [transactions](https://github.com/dusk-network/rusk/blob/8d64e7e63a81ddd7fbe5f92b798d94ddbe46346c/node-data/src/ledger/transaction.rs#L67)
and [faults](https://github.com/dusk-network/rusk/blob/8d64e7e63a81ddd7fbe5f92b798d94ddbe46346c/node-data/src/ledger/faults.rs#L91) are first hashed with SHA3-256.
- [Block Fault IDs](https://github.com/dusk-network/rusk/blob/8d64e7e63a81ddd7fbe5f92b798d94ddbe46346c/node-data/src/ledger/faults.rs#L86): The ID of a block fault is its SHA3-256 hash.
